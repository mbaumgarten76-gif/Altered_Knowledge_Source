name: Build Manifest (generic detection + fixes)

on:
  workflow_dispatch: {}
  push:
    branches: [ main, master ]

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Scan repo and generate manifest & indexes
        run: |
          python - <<'PY'
          import json, os, hashlib, re
          from pathlib import Path
          from datetime import datetime, timezone
          from collections import Counter

          REPO = Path('.').resolve()
          TOP = ["CARDS","COLLECTION","RULES","SETS","DECKS","HISTORY"]
          OUTDIR = REPO / "indexes"
          OUTDIR.mkdir(parents=True, exist_ok=True)

          FACTION_RE = re.compile(r'_(AX|BR|LY|OR|YZ|MU|NE)_', re.I)

          def sha256(p: Path):
            h = hashlib.sha256()
            with p.open('rb') as f:
              for chunk in iter(lambda: f.read(8192), b''):
                h.update(chunk)
            return h.hexdigest()

          def kind_from_top(top: str) -> str:
            return {
              "CARDS":"card","COLLECTION":"collection","RULES":"rule",
              "SETS":"set","DECKS":"deck","HISTORY":"history"
            }.get(top,"other")

          def normalize_rarity_val(val):
            """
            Akzeptiert:
              - String: "Common"/"C", "Rare"/"R"
              - Objekt: {"reference": "RARE", "name":"Rare", ...}
            Gibt zurück: "C" oder "R" (oder None, wenn unbekannt/leer).
            """
            if val is None:
              return None
            if isinstance(val, dict):
              ref = (val.get('reference') or val.get('REFERENCE') or val.get('name') or val.get('NAME') or '').upper()
            else:
              ref = str(val).upper()

            mapping = {
              "COMMON":"C", "C":"C",
              "RARE":"R",   "R":"R",
            }
            return mapping.get(ref, mapping.get(ref.strip(), None)) or None

          def faction_from_filename(filename: str):
            m = FACTION_RE.search(filename)
            return m.group(1).upper() if m else None

          now = datetime.now(timezone.utc).isoformat()
          manifest = {}
          problems = {}

          for top in TOP:
            base = REPO / top
            if not base.exists():
              continue

            for p in base.rglob("*"):
              if p.is_dir():
                continue

              rel = p.relative_to(REPO).as_posix()
              entry = {
                "path": rel,
                "size": p.stat().st_size,
                "mtime": datetime.fromtimestamp(p.stat().st_mtime, tz=timezone.utc).isoformat(),
                "kind": kind_from_top(top),
                "sha256": sha256(p),
                "detected": {},
                "scanned_at": now
              }

              # --- Generische Pfaderkennung für Karten ---
              parts = rel.split("/")
              if parts[0] == "CARDS" and len(parts) >= 4:
                detected_lang = parts[1].upper()
                detected_set  = parts[2].upper()
                detected_fac  = parts[3].upper()

                # Fraktion zusätzlich aus Dateiname (z. B. ..._LY_...)
                inferred_fac = faction_from_filename(parts[-1])
                if inferred_fac and inferred_fac != detected_fac:
                  problems.setdefault(rel, []).append(
                    f"FACTION_MISMATCH: folder={detected_fac} filename={inferred_fac}"
                  )
                  # Policy: Dateinamen bevorzugen (alternativ: Ordner bevorzugen)
                  detected_fac = inferred_fac

                entry["detected"]["lang"] = detected_lang
                entry["detected"]["set"] = detected_set
                entry["detected"]["faction"] = detected_fac

              # --- JSON lesen und Meta-Felder extrahieren ---
              if p.suffix.lower() == ".json":
                try:
                  data = json.loads(p.read_text(encoding="utf-8"))
                  entry["valid_json"] = True
                  if isinstance(data, dict):
                    meta = {}
                    for k in ("id","ref","reference_id","name","type","rarity","faction","set","lang"):
                      if k in data and data[k] is not None:
                        meta[k] = data[k]
                    if meta:
                      entry["meta"] = meta

                    # detected.rarity falls leer aus meta übernehmen & normalisieren
                    if not entry["detected"].get("rarity"):
                      det_r = normalize_rarity_val(meta.get("rarity"))
                      if det_r:
                        entry["detected"]["rarity"] = det_r

                except Exception as e:
                  problems.setdefault(rel, []).append(f"JSON error: {type(e).__name__}: {e}")

              manifest[rel] = entry

          # --- Manifest schreiben ---
          (REPO/"manifest.json").write_text(json.dumps(manifest, ensure_ascii=False, indent=2), encoding="utf-8")

          # --- Indexe erzeugen ---
          def dump(obj, name):
            (OUTDIR/name).write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")

          cards      = [v for v in manifest.values() if v.get("kind")=="card"]
          sets_list  = [v for v in manifest.values() if v.get("kind")=="set"]
          rules_list = [v for v in manifest.values() if v.get("kind")=="rule"]
          decks_list = [v for v in manifest.values() if v.get("kind")=="deck"]
          hist_list  = [v for v in manifest.values() if v.get("kind")=="history"]
          coll_list  = [v for v in manifest.values() if v.get("kind")=="collection"]

          cards_index = {}
          for e in cards:
            d = e.get("detected", {}) or {}
            setcode = (d.get("set") or "UNKNOWN").upper()
            cards_index.setdefault(setcode, []).append({
              "path": e["path"],
              "lang": d.get("lang"),
              "faction": d.get("faction"),
              "rarity": d.get("rarity") or ((e.get("meta") or {}).get("rarity")),
              "name": (e.get("meta") or {}).get("name"),
              "id":   (e.get("meta") or {}).get("id") or (e.get("meta") or {}).get("ref") or (e.get("meta") or {}).get("reference_id"),
            })

          dump(cards_index, "cards_index.json")
          dump({e["path"]: {"sha256": e["sha256"], "detected": e.get("detected", {})} for e in sets_list}, "sets_index.json")
          dump({e["path"]: {"sha256": e["sha256"], "detected": e.get("detected", {})} for e in rules_list}, "rules_index.json")
          dump({e["path"]: {"sha256": e["sha256"], "detected": e.get("detected", {})} for e in decks_list}, "decks_index.json")
          dump({e["path"]: {"sha256": e["sha256"], "detected": e.get("detected", {})} for e in hist_list}, "history_index.json")
          dump({e["path"]: {"sha256": e["sha256"], "detected": e.get("detected", {}), "size": e["size"]} for e in coll_list}, "collection_index.json")

          # --- Kurzstatistiken ---
          fac_counts = Counter(( (v.get("detected") or {}).get("faction") ) for v in cards)
          rar_counts = Counter(( (v.get("detected") or {}).get("rarity") ) for v in cards)
          print("Factions:", dict(fac_counts))
          print("Rarities:", dict(rar_counts))

          # --- Probleme protokollieren (nicht fatal) ---
          if problems:
            (REPO/"scan_problems.json").write_text(json.dumps(problems, ensure_ascii=False, indent=2), encoding="utf-8")
            total = sum(len(v) for v in problems.values())
            print(f"⚠ Found {total} issues -> scan_problems.json")
          else:
            print("No issues found.")

          PY

      - name: Commit manifest & indexes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(manifest): build manifest & indexes (generic detection + fixes)"
          file_pattern: |
            manifest.json
            indexes/**
            scan_problems.json
